# Отчет по лабораторной работе №1 "Изучение оптимизации HMAC"

В данной лабораторной работе исследуется возможность оптимизации HMAC по перебору паролей с помощью ускорения алгоритма хеширования sha1. Для проверки работы при этом используется флаг -o(--opt), который задает условия работы программ: использовать ли оптимизацию или нет. Проверка условия оптимизации происходит в функции key_gen в файле genrator.py. 

Для проведения тестирования скорости подбора пароля используется инструмент hyperfine. А также контрольные функции бенчмарков из файлов benchmark_optimized_hmac.py и benchmark_simple_hmac.py.
## Подробнее об оптимизации

1) Реализация sha1 - переиспользуются блоки (key,opad) и (key,ipad)
2) Благодаря этому, как сказано выше, ускоряется подбор пароля, потому что программа делает меньше вызовов хеширования
3) Вариант ветвления алгоритма через опцию флага  -o(--opt)

## Контрольные цифры для оптимизированного и неоптимизированного алгоритма 

В таблице ниже приведены основные данные о скоростях и времени работы программ с оптимизированным алгоритмом и неоптимизированным. Кроме того указаны маска для перебора паролей, количество слов в словаре для перебора и окончательное количество паролей, которое использовала программа до момента, пока пароль не был найден.

После основных данных, в конце отчета, предоставлены скриншоты результатов проведенных тестирований, где указана более подробная информация, собранная в таблице.

| Маска для пароля(размер словаря) |      Оптимизированный алгоритм      |     Неоптимизированный алгоритм      | Перебираемых паролей |
|:--------------------------------:|:-----------------------------------:|:------------------------------------:|:--------------------:|
|              dd(5)               |   950 cand/sec (309.3ms ± 19.0ms)   |   850  cand/sec (341.3ms ± 14.2ms)   |         213          |
|              dd(12)              |  990  cand/sec (555.9ms ± 11.6ms)   |  850  cand/sec  (640.1ms ± 17.5ms)   |         465          |
|              ddd(5)              |  1300  cand/sec (2.342s ± 0.072s)   |   1150  cand/sec (2.643s ± 0.095s)   |         2924         |
|             ddd(12)              |  1310  cand/sec (4.983s ± 0.142s)   |   1020  cand/sec (6.143s ± 0.362s)   |         6340         |
|             dddd(5)              |  1620  cand/sec (25.298s ± 1.02s)   |  1390  cand/sec (28.243s ± 1.042s)   |        39955         |
|             dddd(12)             |  1620  cand/sec (53.707s ± 1.062s)  |  1390  cand/sec (63.039s ± 1.862s)   |        86575         |
|            ddddd(12)             | 1800  cand/sec (623.053s ± 46.092s) | 1550   cand/sec (703.537s ± 23.442s) |       1142070        |

![](img/opt.png)
*Рисунок 1. Бенчмарк PBKDF2 для неоптимизированного алгоритма хеширования.*

На рисунке 1 представлены замеры, произведенные с помощью кода из файла benchmark_optimized_hmac.py.

![](img/nonopt.png)
*Рисунок 2. Бенчмарк PBKDF2 для оптимизированного алгоритма хеширования.*

На рисунке 2 представлены замеры, произведенные с помощью кода из файла benchmark_simple_hmac.py.


Далее рисунки будут преставлены сокращениями вида: 

[dd*] _ {hmac,opt} _ {5,12}

где dd* - это маска для перебора пароля, hmac или opt - неоптимизированный и оптимизированный алгоритм соответственно, 5 или 12 - количество слов в словаре.
![](img/dd_hmac_5.png)
*Рисунок 3.dd_hmac_5.*

![](img/dd_opt_5.png)
*Рисунок 4.dd_opt_5.*

![](img/dd_hmac_12.png)
*Рисунок 5.dd_opt_12.*

![](img/dd_opt_12.png)
*Рисунок 6.dd_opt_12.*

![](img/ddd_hmac_5.png)
*Рисунок 7.ddd_hmac_5.*

![](img/ddd_opt_5.png)
*Рисунок 8.ddd_opt_5.*

![](img/ddd_hmac_12.png)
*Рисунок 9.ddd_opt_12.*

![](img/ddd_opt_12.png)
*Рисунок 10.ddd_opt_12.*

![](img/dddd_hmac_5.png)
*Рисунок 11.dddd_hmac_5.*

![](img/dddd_opt_5.png)
*Рисунок 12.dddd_opt_5.*

![](img/dddd_hmac_12.png)
*Рисунок 13.dddd_opt_12.*

![](img/dddd_opt_12.png)
*Рисунок 14.dddd_opt_12.*

![](img/ddddd_hmac_12.png)
*Рисунок 15.ddddd_opt_12.*

![](img/ddddd_opt_12.png)
*Рисунок 16.ddddd_opt_12.*